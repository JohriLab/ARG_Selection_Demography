//To run:
//slim -d d_repID='1' -d d_f0=0.51 -d d_f1=0.14 -d d_f2=0.14 -d d_f3=0.21 -d d_f_pos=0 -d d_gamma_pos=125 -d "d_name='production_huber_BGS_nopos_constant'"

initialize() {
///Set general parameters
    defineGlobal("scale", 10);
    defineGlobal("N", 20000);
    defineConstant("Na", asInteger(N/scale));
    defineGlobal("burnin", 14);
    defineGlobal("nSamples", 50);
    setSeed(asInteger(d_repID));


///Set DFE constants
    defineConstant("t0", 0.0);
    defineConstant("t1", -1.0/(2*Na));
    defineConstant("t2", -10.0/(2*Na));
    defineConstant("t3", -100.0/(2*Na));
    defineConstant("t4", -1.0);
    defineConstant("gamma_pos", d_gamma_pos);
    defineConstant("f_pos", d_f_pos);//fraction of beneficial mutations
    defineConstant("f_del", (1.0-f_pos));//fraction of all deleterious classes
    defineConstant("f0", d_f0); //neutral
    defineConstant("f1", d_f1); //weakly del
    defineConstant("f2", d_f2); //mod del
    defineConstant("f3", d_f3); //strong del
    defineConstant("f_intron", 1.54/(33.83+1.54));
    defineConstant("f_interg", 1.63/(43.67+1.63));

///Deleterious DFE
    initializeMutationType("m1", 0.5, "f", 0.0); //neutral coding, 2Nes = [0,-1]
    initializeMutationType("m2", 0.5, "s", "return runif(1, t2, t1);"); // -1<2Nes<-10, uniform distribution
    initializeMutationType("m3", 0.5, "s", "return runif(1, t3, t2);"); //moderately deleterious, -10<2Nes<-100, uniform distribution
    initializeMutationType("m4", 0.5, "s", "return runif(1, t4, t3);"); //strongly deleterious, 2Nes>=-100, uniform distribution
    initializeMutationType("m5", 0.5, "f", 0.0); //neutral intergenic, 2Nes = 0

///Beneficial Muts
    defineConstant("s_pos", gamma_pos/(2.0*Na));
    initializeMutationType("m6", 0.5, "e", s_pos); //beneficial class

///Create genomic elements classes (genes and intergenic)
    initializeGenomicElementType("g1", c(m5, m1, m2, m3, m4, m6), c(1-f_interg,f0*f_del*f_interg, f1*f_del*f_interg, f2*f_del*f_interg, f3*f_del*f_interg, f_pos*f_interg)); //intergenic
    initializeGenomicElementType("g2", c(m5, m1, m2, m3, m4, m6), c(1-f_intron,f0*f_del*f_intron, f1*f_del*f_intron, f2*f_del*f_intron, f3*f_del*f_intron, f_pos*f_intron)); //intronic
    initializeGenomicElementType("g3", c(m1, m2, m3, m4, m6), c(f0*f_del, f1*f_del, f2*f_del, f3*f_del, f_pos)); //exons: weakly deleterious, gamma, need to add m6 for ben muts
    initializeGenomicElementType("g4", c(m1, m2, m3, m4, m6), c(f0*f_del, f1*f_del, f2*f_del, f3*f_del, f_pos)); //5UTR: weakly deleterious, gamma, need to add m6 for ben muts
    initializeGenomicElementType("g5", c(m1, m2, m3, m4, m6), c(f0*f_del, f1*f_del, f2*f_del, f3*f_del, f_pos)); //3UTR: weakly deleterious, gamma, need to add m6 for ben muts

///Set gene parameters
    intron_len = 6938; // Needed Lynch 2006 esimate of 3749, rather than Piovesan 2019's estimate of 6938bp
    exon_len = 311;
    UTR5 = 200;
    UTR3 = 800; //Assumes genes always on positive strand
    num_exons = 11;
    num_introns = 10;
    
    full_gene_len = exon_len*num_exons + intron_len*num_introns;
    gene_block_len = UTR3 + UTR5 + full_gene_len;
    exon_block_len = exon_len + intron_len;
    
///Set genome structure parameters
    num_bins = 138; //Number of 1Mb segments
    bin_size = 1000000; //Size of bins (1Mb)
	 init_token = 300000; token = init_token;//"Telomeric" intergenic length
    ngenes=c(0,13,6,10,3,8,12,7,4,2,5,0,5,4,12,3,0,4,2,1,8,4,0,8,6,6,7,0,8,13,0,3,4,1,13,0,1,0,0,8,3,4,6,2,4,0,3,11,9,7,9,13,3,0,8,13,9,10,10,9,13,8,8,0,0,11,5,3,3,1,3,1,6,13,13,12,8,3,9,7,13,12,3,0,2,13,1,6,1,0,7,4,8,1,3,12,0,13,1,6,7,4,3,0,3,8,10,7,0,3,11,9,5,7,5,13,10,0,8,11,8,3,13,7,8,1,5,13,0,11,5,2,13,5,12,0,8,2); //See gene_density_generation.slim for details
	
//Print summaries, and save constants for printing at end of simulation
    print("gene length = " + full_gene_len);
    print("ngenes per bin printed below:");
	 print(ngenes);   
	  
    defineGlobal("ngenes", asInteger(ngenes));
	 defineConstant("seltot", (exon_len*num_exons*sum(ngenes)+UTR5*sum(ngenes)+UTR3*sum(ngenes) + f_intron*num_introns*sum(ngenes)*intron_len + f_interg*(bin_size*num_bins-gene_block_len*sum(ngenes))));
	 defineConstant("non_int_total", (UTR5+UTR3+exon_len*num_exons+intron_len*num_introns)*sum(ngenes));
	 defineConstant("intron_total", (intron_len*num_introns*sum(ngenes)));

//Build genes with variable density
	initializeGenomicElement(g1, 0, init_token-1);//Add start intergenic

	for (x in 0:(num_bins-1)){ //For each bin
	inter_len = ifelse(ngenes[x] == 0, asFloat(bin_size), (bin_size - ngenes[x]*(full_gene_len + UTR5 + UTR3))/(ngenes[x])); //Calculate length of intergenics for bin
	inter_len = asInteger(inter_len);
	inter_len = ifelse(inter_len < 2, 2, inter_len);
	initializeGenomicElement(g1, token, (token + asInteger(inter_len/2)-1)); //Add start of bin intergenic
	token = token + asInteger(inter_len/2);

		for (y in 0:(ngenes[x])){ //For each gene in bin

			if(y > 0){
			initializeGenomicElement(g4, token, (token + UTR5-1)); // Add 5' UTR
			token = token + UTR5;
	
				for (z in 0:(num_introns-1)){
				initializeGenomicElement(g3, (token + z*exon_block_len), (token + z*exon_block_len + exon_len-1)); //Exons
				initializeGenomicElement(g2, (token + z*exon_block_len + exon_len), (token + z*exon_block_len + exon_len + intron_len-1)); //Introns
				}
				
			initializeGenomicElement(g3, (token + (z+1)*exon_block_len), (token + (z+1)*exon_block_len + exon_len-1)); //Add end exon
			initializeGenomicElement(g5, (token + full_gene_len), (token + full_gene_len + UTR3-1)); //Add 3' UTR
			token = token + full_gene_len + UTR3; 
			}
			if(y != 0  | ngenes[x] == 0){ 
			initializeGenomicElement(g1, token, ifelse(y == ngenes[x], token + asInteger(inter_len/2)-1, (token + inter_len-1))); //Add post-gene intergenic
			token = token + ifelse(y == ngenes[x], asInteger(inter_len/2), inter_len);
			}
		}
	}

	initializeGenomicElement(g1, token, (token + init_token));//Add end intergenic
//End build genes



    initializeMutationRate(scale*1.25e-8);
    initializeRecombinationRate(scale*1e-8);
}


1 early() {
    sim.addSubpop("p1", asInteger(N/scale));
}

27999 late() {
    print("N prior to pop change: " + p1.individualCount);
}


28000:30000 early() {
t = (community.tick - asInteger(burnin*N/scale));
p1_size = round(asInteger(N/scale) + round((0.0002*scale*t^2)));
p1.setSubpopulationSize(asInteger(p1_size));
//asInteger(round(asInteger(N/scale)-(0.1*exp(1*t)))));
}


30000 late(){
p1.outputVCFSample(sampleSize=nSamples, outputMultiallelics=F, filePath="/work/users/j/i/jimarsh/test_sims/SLiM/dfe_re_productionbox/" + d_name + "_R" + d_repID + ".vcf", append=F, outputNonnucleotides=T);

   sim.outputFixedMutations(); 

    print("N at the end of simulation: " + p1.individualCount);
    print("The last base in the chromosome: " + sim.chromosome.lastPosition + " (" + asInteger(sim.chromosome.lastPosition)/1000000 + "Mb)");
    print("Number of genes = " + sum(ngenes));
    print("Proportion under DFE = " + (seltot/sim.chromosome.lastPosition));
    print("Proportion selected = " + (seltot/sim.chromosome.lastPosition)*(1-f0));
   prop_interg = (sim.chromosome.lastPosition-non_int_total)/sim.chromosome.lastPosition;
    print("Proportion intergenic = " + prop_interg);
   prop_intron = (intron_total/sim.chromosome.lastPosition);
    print("Proportion intronic = " + prop_intron); 
    print("Total nMutations = " + size(sim.mutations));
    print("Theta pi for all mutations = " + (calcHeterozygosity(genomes=p1.genomes)));
    print("Theta pi for neutral interg/intron across whole genome = " + (calcHeterozygosity(genomes=p1.genomes, muts=sim.mutationsOfType(m5))));    
    print("Rep" + d_repID + " theta pi for neutral interg/intron, size corrected = " + (calcHeterozygosity(genomes=p1.genomes, muts=sim.mutationsOfType(m5))/((prop_intron-prop_intron*f_intron) + (prop_interg-prop_interg*f_interg))));
    print("m1 = " + (sim.countOfMutationsOfType(m1)/size(sim.mutations)) + "(f0)");
    print("m2 = " + (sim.countOfMutationsOfType(m2)/size(sim.mutations)) + "(f1)");
    print("m3 = " + (sim.countOfMutationsOfType(m3)/size(sim.mutations)) + "(f2)");
    print("m4 = " + (sim.countOfMutationsOfType(m4)/size(sim.mutations)) + "(f3)");
    print("m5 = " + (sim.countOfMutationsOfType(m5)/size(sim.mutations)) + "(interg/intron neutral)");
    print("m6 = " + (sim.countOfMutationsOfType(m6)/size(sim.mutations)));


}
